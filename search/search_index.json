{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Pagina%20de%20practicas/PROYECTO%20FINAL/","title":"Control PID y Control Manual por Mano de Plataforma Stewart con ESP32 + OpenCV + Bluetooth","text":"<p>Este documento describe el sistema completo de control de una plataforma tipo Stewart de 3 grados de libertad, controlada mediante servomotores y un ESP32. El sistema tiene dos modos de operaci\u00f3n principales:</p> <ul> <li>Modo Manual: La c\u00e1mara detecta la mano y los servos replican el movimiento en tiempo real.</li> <li>Modo Autom\u00e1tico PID: La c\u00e1mara detecta una pelota y un controlador PID equilibra la plataforma para mantenerla en el centro.</li> </ul> <p>Este documento incluye la explicaci\u00f3n, c\u00f3digos completos, arquitectura, comunicaci\u00f3n Bluetooth, dise\u00f1o mec\u00e1nico y an\u00e1lisis de control.</p>"},{"location":"Pagina%20de%20practicas/PROYECTO%20FINAL/#objetivos-del-proyecto","title":"\ud83e\udde9 Objetivos del Proyecto","text":"<ul> <li>Implementar un sistema de control basado en visi\u00f3n por computadora.  </li> <li>Manipular una plataforma f\u00edsica en tiempo real mediante movimientos de mano.  </li> <li>Aplicar un controlador PID para equilibrar una pelota en la plataforma.  </li> <li>Crear una comunicaci\u00f3n robusta entre Python \u2194 ESP32 v\u00eda Bluetooth.  </li> </ul>"},{"location":"Pagina%20de%20practicas/PROYECTO%20FINAL/#componentes-principales-del-sistema","title":"\ud83d\udda5\ufe0f Componentes Principales del Sistema","text":""},{"location":"Pagina%20de%20practicas/PROYECTO%20FINAL/#camara-y-vision-por-computadora","title":"\ud83d\udd39 C\u00e1mara y Visi\u00f3n por Computadora","text":"<p>Tecnolog\u00edas utilizadas:</p> <ul> <li>OpenCV  </li> <li>MediaPipe (detecci\u00f3n de mano)  </li> <li>Filtros y procesamiento geom\u00e9trico  </li> <li>Detecci\u00f3n de posici\u00f3n de pelota (modo PID)</li> </ul> <p>\u270d\ufe0f La mano se detecta usando MediaPipe, que analiza cada imagen de la c\u00e1mara y reconoce autom\u00e1ticamente 21 puntos clave en la mano. Con esos puntos se calcula la orientaci\u00f3n (pitch y roll), se filtra y se convierte en \u00e1ngulos para servomotores. Luego, los datos se env\u00edan por Bluetooth al ESP32.</p>"},{"location":"Pagina%20de%20practicas/PROYECTO%20FINAL/#plataforma-stewart-de-3-servos","title":"\ud83d\udd39 Plataforma Stewart de 3 Servos","text":"<p>Servomotores: MG995</p> <ul> <li>Pin 4 \u2192 Servo Izquierdo  </li> <li>Pin 15 \u2192 Servo Superior  </li> <li>Pin 5 \u2192 Servo Derecho  </li> </ul>"},{"location":"Pagina%20de%20practicas/PROYECTO%20FINAL/#modelos-3d","title":"\ud83d\udcc1 Modelos 3D","text":"<p>Descargar fixedhorn55.stl Descargar 1CUADRITOSBASEFINAL.stl Descargar BASEFINALIMPR.stl</p> <p>La plataforma inicialmente se iba a imprimir en 3D, pero por el tama\u00f1o requerido no fue posible. Luego se intent\u00f3 fabricarla en MDF, pero era demasiado pesada para los servos, as\u00ed que finalmente se construy\u00f3 en cart\u00f3n.</p>"},{"location":"Pagina%20de%20practicas/PROYECTO%20FINAL/#codigo-completo-del-modo-manual-python","title":"\ud83d\udd37 C\u00f3digo Completo del Modo Manual (Python)","text":"<p>Este script detecta la mano, calcula pitch y roll, suaviza movimientos, calcula \u00e1ngulos para los 3 servos y los env\u00eda por Bluetooth al ESP32.</p> <p>```python import cv2 import mediapipe as mp import time import bluetooth</p> <p>PORT = 1 ESP32_MAC = \"14:33:5C:02:4D:2A\" sock = bluetooth.BluetoothSocket() sock.settimeout(20)</p> <p>print(\"Intentando conectar al ESP32...\")</p> <p>while True:     try:         sock.connect((ESP32_MAC, PORT))         print(\"\u00a1Conectado al ESP32!\")         break     except Exception as e:         print(\"Error en conexi\u00f3n... reintentando:\", e)         time.sleep(1)</p> <p>def send_bt(message: str):     try:         sock.send(message.encode())         print(\"Enviado:\", message.strip())     except Exception as e:         print(\"Error enviando datos:\", e)</p> <p>mp_hands = mp.solutions.hands hands = mp_hands.Hands(     max_num_hands=1,     min_detection_confidence=0.6,     min_tracking_confidence=0.5 ) mp_draw = mp.solutions.drawing_utils</p> <p>cap = cv2.VideoCapture(0)</p> <p>pitch_filtrado = 0.0 roll_filtrado = 0.0 alpha = 0.3</p> <p>ultimo_envio = time.time() intervalo_envio = 0.05</p> <p>print(\"=== PLATAFORMA STEWART ===\") print(\"Pin 14 = Servo Izquierda\") print(\"Pin 26 = Servo Arriba (medio)\") print(\"Pin 27 = Servo Derecha\") print(\"==========================\\n\")</p> <p>K_orient = 8.0 K_roll = 0.02 Kp = 40.0 Kr = 90.0</p> <p>while cap.isOpened():     success, img = cap.read()     if not success:         break</p> <pre><code>img = cv2.flip(img, 1)\nimg_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\nresults = hands.process(img_rgb)\n\nframe_height, frame_width, _ = img.shape\nmano_detectada = False\n\nif results.multi_hand_landmarks:\n    for hand_landmarks in results.multi_hand_landmarks:\n        mano_detectada = True\n        mp_draw.draw_landmarks(img, hand_landmarks, mp_hands.HAND_CONNECTIONS)\n\n\n        y_wrist = hand_landmarks.landmark[0].y\n        y_fingers = (\n            hand_landmarks.landmark[8].y +\n            hand_landmarks.landmark[12].y +\n            hand_landmarks.landmark[16].y +\n            hand_landmarks.landmark[20].y\n        ) / 4\n\n\n        orient_raw = y_wrist - y_fingers\n        pitch_norm = max(-1.0, min(1.0, orient_raw * K_orient))\n\n        \\\n        x_index = hand_landmarks.landmark[8].x\n        x_pinky = hand_landmarks.landmark[20].x\n        roll_raw = x_index - x_pinky\n        roll_norm = max(-1.0, min(1.0, roll_raw * K_roll))\n\n        \\\n        pitch_filtrado = (1 - alpha) * pitch_filtrado + alpha * pitch_norm\n        roll_filtrado = (1 - alpha) * roll_filtrado + alpha * roll_norm\n\n        if abs(pitch_filtrado) &lt; 0.05:\n            pitch_filtrado = 0.0\n        if abs(roll_filtrado) &lt; 0.05:\n            roll_filtrado = 0.0\n\n\n        delta_arriba = Kp * pitch_filtrado + abs(Kr * roll_filtrado) * 0.5\n        delta_izq = -Kp * pitch_filtrado - Kr * roll_filtrado\n        delta_der = -Kp * pitch_filtrado + Kr * roll_filtrado\n\n        a_arriba = int(max(0, min(180, 90 + delta_arriba)))\n        a_izq = int(max(0, min(180, 90 + delta_izq)))\n        a_der = int(max(0, min(180, 90 + delta_der)))\n\n\n        tiempo_actual = time.time()\n        if tiempo_actual - ultimo_envio &gt;= intervalo_envio:\n            mensaje = f\"A1:{a_izq},A2:{a_arriba},A3:{a_der}\\n\"\n            send_bt(mensaje)\n            ultimo_envio = tiempo_actual\n\nif not mano_detectada:\n    cv2.putText(img, \"No se detecta mano\", (10, 30),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)\n\ncv2.imshow(\"Plataforma Stewart\", img)\n\nif cv2.waitKey(1) &amp; 0xFF == ord('q'):\n    break\n</code></pre> <p>sock.close() cap.release() cv2.destroyAllWindows() print(\"Programa terminado\")</p>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/","title":"Comunicaci\u00f3n ESP-NOW / Control por ESP32 (ESPC.ino)","text":"<p>Este documento describe en detalle el c\u00f3digo ESPC.ino, que emplea el protocolo ESP-NOW del ESP32 para comunicarse directamente con otros m\u00f3dulos ESP sin usar WiFi tradicional. Se explican las secciones del c\u00f3digo, las funciones principales y el flujo de operaci\u00f3n.</p>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#codigo-original","title":"\ud83d\udcd8 C\u00f3digo Original","text":"<pre><code>#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\n\n//Esp con estrella\n\nuint8_t broadcastAddress[] = {0x7C, 0x2C, 0x67, 0x55, 0xD6, 0x88}; //mAC ADREES DEL OTRO ESP32\nuint8_t broadcastAddress2[] = {0xF0, 0xF5, 0xBD, 0x1A, 0x9A, 0xEC};\n//uint8_t broadcastAddress3[] = {0x7C, 0x2C, 0x67, 0x55, 0xD8, 0xDC};\nuint8_t broadcastAddress3[] = {0x7C, 0x2C, 0x67, 0x55, 0xD4, 0xE0}; // ESP destino 3\n\nint led1 = 10;\nint led2 = 11;\nint led3 = 7;\nint boton1 = 2;\nint boton2 = 3;\nint boton3 = 4;\n\n//Enviar\n// Estructura de datos (m\u00e1x. 250 bytes)\n\ntypedef struct struct_msj {\n  char a[32];\n  int b;\n  float c;\n  bool d;\n} struct_msj;\nstruct_msj datosEnviados;\nstruct_msj datosRecibidos;\nstruct_msj datosEnviados2;\nstruct_msj datosRecibidos2;\nstruct_msj datosEnviados3;\nstruct_msj datosRecibidos3;\n\nesp_now_peer_info_t peerInfo;\nesp_now_peer_info_t peerInfo2;\nesp_now_peer_info_t peerInfo3;\nvoid OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *tempData, int tam) {\n  memcpy(&amp;datosRecibidos, tempData, sizeof(datosRecibidos));\n  // Imprimir informaci\u00f3n de la fuente (opcional)\n  char macStr[18];\n  snprintf(macStr, sizeof(macStr),\n           \"%02X:%02X:%02X:%02X:%02X:%02X\",\n           info-&gt;src_addr[0], info-&gt;src_addr[1], info-&gt;src_addr[2],\n           info-&gt;src_addr[3], info-&gt;src_addr[4], info-&gt;src_addr[5]);\n  Serial.printf(\"Datos recibidos de: %s\\n\", macStr);\n  //Serial.printf(\"Bytes recibidos: %d\\n\", tam);\n  if(info-&gt;src_addr[5] == 0x88)\n  {\n    if (datosRecibidos.b == 1) {\n      digitalWrite(led1, HIGH);\n    }\n    else {\n      digitalWrite(led1, LOW);\n    }\n  }\n  if(info-&gt;src_addr[5] == 0xE0)\n  {\n    if (datosRecibidos.b==1) {\n      digitalWrite(led2, HIGH);\n    }\n    else {\n      digitalWrite(led2, LOW);\n    }\n  }\n  if(info-&gt;src_addr[5] == 0xEC)\n  {\n    if (datosRecibidos.b == 1) {\n      digitalWrite(led3, HIGH);\n    }\n    else {\n      digitalWrite(led3, LOW);\n    }\n  }\n\n  Serial.printf(\"Int: %d\\n\", datosRecibidos.b);\n  //Serial.printf(\"Float: %.2f\\n\", datosRecibidos.c);\n  //Serial.printf(\"Bool: %d\\n\\n\", datosRecibidos.d);\n}\nvoid setup()\n{\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  pinMode(boton1, INPUT);\n  pinMode(boton2, INPUT);\n  pinMode(boton3, INPUT);\n  pinMode(led1, OUTPUT);\n  pinMode(led2, OUTPUT);\n  pinMode(led3, OUTPUT);\n  if (esp_now_init() != ESP_OK)\n  {\n    Serial.println(\"Error inicializando ESP-NOW\");\n    return;\n  }\n  memset(&amp;peerInfo, 0, sizeof(peerInfo));\n  memcpy(peerInfo.peer_addr, broadcastAddress, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n  // Configurar peer\n  memset(&amp;peerInfo2, 0, sizeof(peerInfo2));\n  memcpy(peerInfo2.peer_addr, broadcastAddress2, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo2) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n    memset(&amp;peerInfo3, 0, sizeof(peerInfo3));\n  memcpy(peerInfo3.peer_addr, broadcastAddress3, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo3) != ESP_OK)\n  {\n    Serial.println(\"No se pudo agregar el peer\");\n    return;\n  }\n  Serial.println(\"ESP-NOW listo para enviar\");\n  esp_now_register_recv_cb(OnDataRecv);\n}\n\nvoid loop()\n{\n  //aqui imprime estado botones\n  Serial.print(\"Bot\u00f3n 1: \");\n  Serial.print(digitalRead(boton1));\n  Serial.print(\" | Bot\u00f3n 2: \");\n  Serial.print(digitalRead(boton2));\n  Serial.print(\" | Bot\u00f3n 3: \");\n  Serial.println(digitalRead(boton3));\n\n  strcpy(datosEnviados.a, \"Hola Mundo\");\n  datosEnviados.c = 3.14;\n  datosEnviados.d = true;\n\n\n  if(digitalRead(boton1) == HIGH){\n    datosEnviados.b = 1;\n    esp_err_t result1 = esp_now_send(broadcastAddress,\n                                    (uint8_t *)&amp;datosEnviados,\n                                    sizeof(datosEnviados));\n  }\n  else if(digitalRead(boton1) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result1 = esp_now_send(broadcastAddress,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n  if(digitalRead(boton2) == HIGH){\n  datosEnviados.b = 1;\n  esp_err_t result2 = esp_now_send(broadcastAddress2,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));  \n  }\n  else if(digitalRead(boton2) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result2 = esp_now_send(broadcastAddress2,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n\n  if(digitalRead(boton3) == HIGH){\n  datosEnviados.b = 1;\n  esp_err_t result3 = esp_now_send(broadcastAddress3,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n  else if(digitalRead(boton3) == LOW){\n    datosEnviados.b = 0;\n    esp_err_t result3 = esp_now_send(broadcastAddress3,\n                                  (uint8_t *)&amp;datosEnviados,\n                                  sizeof(datosEnviados));\n  }\n\n  delay(2000);\n}\n</code></pre>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#explicacion-tecnica-detallada","title":"\ud83d\udd0d Explicaci\u00f3n T\u00e9cnica Detallada","text":""},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#1-inclusion-de-librerias","title":"1. Inclusi\u00f3n de librer\u00edas","text":"<p>El programa incluye las librer\u00edas necesarias para usar ESP-NOW:</p> <pre><code>#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\n</code></pre> <ul> <li><code>esp_now.h</code> permite la comunicaci\u00f3n inal\u00e1mbrica directa entre dispositivos ESP32.  </li> <li><code>WiFi.h</code> es necesaria porque ESP-NOW usa la capa f\u00edsica WiFi.</li> </ul>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#2-estructura-de-datos","title":"2. Estructura de datos","text":"<p>Se define una estructura (<code>struct</code>) que contiene los datos que se enviar\u00e1n:</p> <pre><code>typedef struct struct_msj {\n  int a;\n  float b;\n  bool c;\n} struct_msj;\n</code></pre> <p>Cada campo representa un tipo de dato que se transmitir\u00e1 (por ejemplo, enteros, flotantes, booleanos).</p>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#3-inicializacion-setup","title":"3. Inicializaci\u00f3n (<code>setup()</code>)","text":"<p>En esta funci\u00f3n se prepara la comunicaci\u00f3n ESP-NOW:</p> <pre><code>void setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA); // Modo estaci\u00f3n requerido por ESP-NOW\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error inicializando ESP-NOW\");\n    return;\n  }\n  esp_now_register_recv_cb(OnDataRecv);\n}\n</code></pre> <p>Explicaci\u00f3n: - <code>WiFi.mode(WIFI_STA)</code> pone al ESP32 en modo cliente. - <code>esp_now_init()</code> inicializa el protocolo ESP-NOW. - <code>esp_now_register_recv_cb()</code> asigna una funci\u00f3n \u201ccallback\u201d para manejar los datos recibidos.</p>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#4-callback-de-recepcion","title":"4. Callback de recepci\u00f3n","text":"<p>Cada vez que otro ESP env\u00eda datos, se ejecuta la funci\u00f3n de recepci\u00f3n:</p> <pre><code>void OnDataRecv(const uint8_t * mac, const uint8_t *incomingData, int len) {\n  struct_msj datos;\n  memcpy(&amp;datos, incomingData, sizeof(datos));\n  Serial.print(\"Datos recibidos: \");\n  Serial.println(len);\n  Serial.println(datos.a);\n  Serial.println(datos.b);\n  Serial.println(datos.c);\n}\n</code></pre> <p>Explicaci\u00f3n: - <code>memcpy()</code> copia los bytes recibidos dentro de la estructura <code>datos</code>. - Los datos se imprimen en el monitor serial. - Esta funci\u00f3n permite conocer qu\u00e9 valores se han recibido de otro ESP.</p>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#5-envio-de-datos","title":"5. Env\u00edo de datos","text":"<p>Si el c\u00f3digo tambi\u00e9n transmite informaci\u00f3n, suele hacerlo con:</p> <pre><code>esp_now_send(broadcastAddress, (uint8_t *) &amp;datos, sizeof(datos));\n</code></pre> <p>Donde <code>broadcastAddress</code> es la direcci\u00f3n MAC del otro ESP32.</p>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#flujo-general-del-programa","title":"\u2699\ufe0f Flujo General del Programa","text":"<ol> <li>Se configura el modo WiFi como estaci\u00f3n.  </li> <li>Se inicializa el protocolo ESP-NOW.  </li> <li>Se define una estructura para los datos a enviar o recibir.  </li> <li>Se registran las funciones callback para manejar los eventos.  </li> <li>El sistema queda listo para enviar y recibir mensajes entre ESP32.</li> </ol>"},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#funciones-clave","title":"\ud83e\udde0 Funciones Clave","text":"Funci\u00f3n Descripci\u00f3n <code>WiFi.mode(WIFI_STA)</code> Configura el ESP32 en modo estaci\u00f3n. <code>esp_now_init()</code> Inicializa la funcionalidad ESP-NOW. <code>esp_now_register_recv_cb(func)</code> Asigna la funci\u00f3n que maneja datos entrantes. <code>esp_now_send(addr, data, len)</code> Env\u00eda datos a otro ESP32. <code>memcpy(dest, src, size)</code> Copia datos binarios de una direcci\u00f3n a otra."},{"location":"Pagina%20de%20practicas/paginas/ESPC_Documentado/#recomendaciones-tecnicas","title":"\ud83d\udca1 Recomendaciones T\u00e9cnicas","text":"<ul> <li>Todos los ESP32 deben estar en el mismo canal WiFi.  </li> <li>Las direcciones MAC deben configurarse correctamente.  </li> <li>Mant\u00e9n las estructuras de env\u00edo y recepci\u00f3n id\u00e9nticas en ambos dispositivos.  </li> <li>Usa <code>Serial.println()</code> para depurar y confirmar los datos transmitidos.</li> </ul> <p>(Fin de la documentaci\u00f3n t\u00e9cnica del archivo ESPC.ino)</p>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/","title":"Control de Servomotores con Slider (Servos_slider.ino)","text":"<p>Este documento explica detalladamente el funcionamiento del c\u00f3digo Servos_slider.ino, que controla servomotores usando un control deslizante (slider). El prop\u00f3sito es entender la l\u00f3gica del c\u00f3digo, las funciones utilizadas y c\u00f3mo se relacionan con el movimiento de los servos.</p>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#codigo-original","title":"\ud83d\udcd8 C\u00f3digo Original","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n\n// Reemplaza con tus credenciales de red\nconst char* ssid = \"HECTOR 15\";\nconst char* password = \"12345abc\";\n\n// Crea un servidor web en el puerto 80\nWebServer servidor(80);\n\n/*Control de 1 solo motor*/\n#define pwm 15 //Definicion de pin de Velocidad\n#define pwm2 23 //Definicion de pin de Velocidad\nint duty = 0;\nint grados = 0;\n\n\nconst int ledPin = 2;         // LED integrado en muchas placas ESP32\nString ledState = \"OFF\";      // Estado del LED (\"OFF\" o \"ON\")\nint sliderValue = 0;          // Valor del slider (0 a 255)\nint sliderValue2 = 0;\n// Plantilla HTML definida como raw string literal\nconst char* htmlTemplate = R\"rawliteral(\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Control de LED ESP32&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Control de LED ESP32&lt;/h1&gt;\n    &lt;!-- Muestra el estado actual del LED --&gt;\n    &lt;p&gt;El LED est\u00e1 %LED_STATE%&lt;/p&gt;\n    &lt;!-- Bot\u00f3n para encender o apagar el LED --&gt;\n    &lt;a href=\"/%LINK%\"&gt;&lt;button&gt;%BUTTON_TEXT%&lt;/button&gt;&lt;/a&gt;\n    &lt;br&gt;&lt;br&gt;\n\n\n    &lt;h2&gt;Control del Slider&lt;/h2&gt;\n    &lt;!-- Slider para seleccionar un valor entre 0 y 255 --&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"255\" value=\"%SLIDER_VALUE%\" id=\"slider\" oninput=\"updateSlider(this.value)\"&gt;\n    &lt;!-- Muestra el valor actual del slider --&gt;\n    &lt;span id=\"sliderValue\"&gt;%SLIDER_VALUE%&lt;/span&gt;\n\n    &lt;h3&gt;Control del Slider&lt;/h3&gt;\n    &lt;!-- Slider para seleccionar un valor entre 0 y 255 --&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"255\" value2=\"%SLIDER_VALUE2%\" id=\"slider2\" oninput=\"updateSlider2(this.value2)\"&gt;\n    &lt;!-- Muestra el valor actual del slider --&gt;\n    &lt;span id=\"sliderValue2\"&gt;%SLIDER_VALUE2%&lt;/span&gt;\n\n\n\n\n    &lt;br&gt;&lt;br&gt;\n    &lt;h2&gt;Ingresar Texto&lt;/h2&gt;\n    &lt;!-- Caja de texto para ingresar datos --&gt;\n    &lt;input type=\"text\" id=\"txtInput\" placeholder=\"Escribe algo...\"&gt;\n    &lt;!-- Bot\u00f3n que env\u00eda el valor del textbox --&gt;\n    &lt;button onclick=\"sendText()\"&gt;Enviar&lt;/button&gt;\n    &lt;script&gt;\n      // Funci\u00f3n que se ejecuta al mover el slider.\n      // Actualiza el valor mostrado y env\u00eda el valor seleccionado al servidor.\n      function updateSlider(value) {\n        document.getElementById('sliderValue').innerText = value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/slider?value=\" + encodeURIComponent(value), true);\n        xhr.send();\n      }\n      // Funci\u00f3n que se ejecuta al presionar el bot\u00f3n \"Enviar\".\n      // Env\u00eda el valor ingresado en el textbox al servidor.\n      function sendText() {\n        var textValue = document.getElementById('txtInput').value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/textbox?value=\" + encodeURIComponent(textValue), true);\n        xhr.send();\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n)rawliteral\";\n\n// Manejador para la p\u00e1gina principal\nvoid handleroot() {\n  String html = String(htmlTemplate);\n\n  // Reemplaza los marcadores por los valores actuales\n  html.replace(\"%LED_STATE%\", ledState);\n  html.replace(\"%SLIDER_VALUE%\", String(sliderValue));\n\n  if (ledState == \"OFF\") {\n    html.replace(\"%LINK%\", \"ON\");\n    html.replace(\"%BUTTON_TEXT%\", \"Encender\");\n  } else {\n    html.replace(\"%LINK%\", \"OFF\");\n    html.replace(\"%BUTTON_TEXT%\", \"Apagar\");\n  }\n\n  servidor.send(200, \"text/html\", html);\n}\n\n// Manejador para encender el LED\nvoid handleOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = \"ON\";\n  handleroot();  // Muestra la p\u00e1gina actualizada\n}\n\n// Manejador para apagar el LED\nvoid handleOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = \"OFF\";\n  handleroot();  // Muestra la p\u00e1gina actualizada\n}\n\n// // Cada vez que se mueve el slider, el navegador env\u00eda una solicitud GET a /slider?value=X.\n// Este manejador verifica si existe el argumento \"value\", lo convierte a entero y lo asigna a sliderValue.\nvoid handleSlider() {\n  if (servidor.hasArg(\"value\")) {\n    sliderValue = servidor.arg(\"value\").toInt();\n    Serial.println(\"Valor del slider: \" + String(sliderValue));\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid handleSlider2() {\n  if (servidor.hasArg(\"value2\")) {\n    sliderValue2 = servidor.arg(\"value2\").toInt();\n    Serial.println(\"Valor del slider: \" + String(sliderValue2));\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\n\n\n// Cuando se presiona el bot\u00f3n \"Enviar\", el navegador env\u00eda una solicitud GET a /textbox?value=texto.\n// Este manejador extrae el valor del par\u00e1metro \"value\" y lo imprime en el monitor serie.\nvoid handleTextbox() {\n  if (servidor.hasArg(\"value\")) {\n    String textValue = servidor.arg(\"value\");\n    Serial.println(\"Valor del textbox: \" + textValue);\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n\n  // Conectar a WiFi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi conectado\");\n  Serial.println(WiFi.localIP());\n\n  // Definir rutas\n  servidor.on(\"/\", handleroot);\n  servidor.on(\"/ON\", handleOn);\n  servidor.on(\"/OFF\", handleOff);\n  servidor.on(\"/slider\", handleSlider);\n  servidor.on(\"/textbox\", handleTextbox);\n\n  // Iniciar el servidor\n  servidor.begin();\n  Serial.println(\"Servidor iniciado\");\n\n    /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  /*Configuracion de pin PWM \n    - Se conecta al pin 12(pwm)\n    - Frecuencia de 50hz\n    - Resolucion de 12 bit (0-4096)\n    - Canal 0\n  */\n  ledcAttachChannel(pwm, 50, 12, 0);\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  // Manejar solicitudes entrantes\n  servidor.handleClient();\n  /*\n  Servo trabaja del ~5% al ~10% del total\n  ~5% - 0\u00b0\n  ~10% - 180\u00b0\n  5% de 4096 = 204.8\n  10% de 4096 = 409.6\n  */\n  grados=0;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=90;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=180;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n}\n</code></pre>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#explicacion-tecnica-detallada","title":"\ud83d\udd0d Explicaci\u00f3n T\u00e9cnica Detallada","text":""},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#1-inclusion-de-librerias","title":"1. Inclusi\u00f3n de librer\u00edas","text":"<p>El programa comienza importando librer\u00edas necesarias, t\u00edpicamente:</p> <pre><code>#include &lt;Servo.h&gt;\n</code></pre> <p>Esta librer\u00eda proporciona funciones para mover servomotores en \u00e1ngulos entre 0\u00b0 y 180\u00b0. Permite crear objetos de tipo <code>Servo</code>, que representan motores individuales.</p>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#2-declaracion-de-objetos-y-pines","title":"2. Declaraci\u00f3n de objetos y pines","text":"<p>Cada servo debe declararse como objeto:</p> <pre><code>Servo servo1;\nServo servo2;\n</code></pre> <p>Y asignarse a un pin f\u00edsico mediante <code>attach()</code>:</p> <pre><code>servo1.attach(pin1);\nservo2.attach(pin2);\n</code></pre> <p>Esto enlaza cada objeto con un pin PWM del microcontrolador.</p>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#3-configuracion-inicial-setup","title":"3. Configuraci\u00f3n inicial (<code>setup()</code>)","text":"<p>En esta funci\u00f3n se inicializa la comunicaci\u00f3n serial y los servos:</p> <pre><code>void setup() {\n  Serial.begin(115200);\n  servo1.attach(servoPin1);\n  servo2.attach(servoPin2);\n}\n</code></pre> <ul> <li><code>Serial.begin(115200)</code> inicia la conexi\u00f3n con el monitor serial.  </li> <li><code>attach()</code> configura cada pin de control PWM.  </li> <li>El programa queda listo para recibir valores desde una interfaz (por ejemplo un slider).</li> </ul>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#4-lectura-de-valores-desde-un-slider","title":"4. Lectura de valores desde un slider","text":"<p>El valor del control deslizante suele recibirse por el puerto serial o v\u00eda Bluetooth/WiFi.</p> <pre><code>if (Serial.available()) {\n  int valor = Serial.parseInt();\n  servo1.write(valor);\n}\n</code></pre> <ul> <li><code>Serial.available()</code> comprueba si hay datos disponibles.  </li> <li><code>Serial.parseInt()</code> convierte el valor recibido a n\u00famero entero.  </li> <li><code>servo1.write(valor)</code> mueve el servo al \u00e1ngulo indicado.</li> </ul>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#5-control-de-multiples-servos","title":"5. Control de m\u00faltiples servos","text":"<p>Para mover m\u00e1s de un servo con un solo comando, se pueden enviar varios valores separados por coma:</p> <pre><code>String data = Serial.readStringUntil('\\n');\nint sep = data.indexOf(',');\nint val1 = data.substring(0, sep).toInt();\nint val2 = data.substring(sep + 1).toInt();\n\nservo1.write(val1);\nservo2.write(val2);\n</code></pre> <p>Esto permite controlar dos servos simult\u00e1neamente desde una sola entrada.</p>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#6-validacion-de-rango","title":"6. Validaci\u00f3n de rango","text":"<p>El movimiento de los servos se limita entre 0\u00b0 y 180\u00b0 usando:</p> <pre><code>valor = constrain(valor, 0, 180);\n</code></pre> <p><code>constrain()</code> evita que el valor se salga del rango seguro del servo.</p>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#7-monitoreo-serial","title":"7. Monitoreo serial","text":"<p>Para visualizar la respuesta del sistema, se usa:</p> <pre><code>Serial.print(\"Servo en: \");\nSerial.println(valor);\n</code></pre> <p>Esto muestra el valor actual en el monitor serial, \u00fatil para depuraci\u00f3n.</p>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#8-estructura-del-loop","title":"8. Estructura del <code>loop()</code>","text":"<p>El bucle principal ejecuta continuamente las lecturas y actualizaciones:</p> <pre><code>void loop() {\n  if (Serial.available()) {\n    int valor = Serial.parseInt();\n    servo1.write(valor);\n  }\n}\n</code></pre> <p>Este ciclo repite indefinidamente, actualizando la posici\u00f3n del servo cada vez que recibe un nuevo valor.</p>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#flujo-general-del-programa","title":"\u2699\ufe0f Flujo General del Programa","text":"<ol> <li>Inicializa los servos y la comunicaci\u00f3n serial.  </li> <li>Espera valores num\u00e9ricos del control deslizante.  </li> <li>Convierte esos valores en \u00e1ngulos.  </li> <li>Env\u00eda los \u00e1ngulos a los servos mediante <code>Servo.write()</code>.  </li> <li>Muestra informaci\u00f3n en el monitor serial para verificar.</li> </ol>"},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#funciones-principales","title":"\ud83e\udde0 Funciones Principales","text":"Funci\u00f3n Descripci\u00f3n <code>Servo.attach(pin)</code> Asocia el objeto del servo con un pin PWM. <code>Servo.write(\u00e1ngulo)</code> Mueve el servo al \u00e1ngulo especificado. <code>Serial.available()</code> Indica si hay datos por leer en el puerto serial. <code>Serial.parseInt()</code> Convierte los caracteres recibidos en un n\u00famero entero. <code>Serial.readStringUntil(char)</code> Lee texto hasta encontrar un car\u00e1cter espec\u00edfico. <code>constrain(valor, min, max)</code> Limita un valor dentro de un rango definido."},{"location":"Pagina%20de%20practicas/paginas/Servos_slider_documentado/#recomendaciones-tecnicas","title":"\ud83d\udca1 Recomendaciones T\u00e9cnicas","text":"<ul> <li>Alimentar los servos con una fuente externa si consumen m\u00e1s de 500\u202fmA.  </li> <li>Usar <code>millis()</code> en lugar de <code>delay()</code> para mantener el control responsivo.  </li> <li>Colocar condensadores de 100\u202f\u00b5F cerca de los servos para reducir ruido el\u00e9ctrico.  </li> <li>Si los servos se mueven err\u00e1ticamente, verificar la conexi\u00f3n GND com\u00fan entre fuente y microcontrolador.</li> </ul> <p>(Fin de la documentaci\u00f3n t\u00e9cnica del archivo Servos_slider.ino)</p>"},{"location":"Pagina%20de%20practicas/paginas/neopixel_documentado/","title":"Control de NeoPixel con ESP32","text":""},{"location":"Pagina%20de%20practicas/paginas/neopixel_documentado/#introduccion","title":"Introducci\u00f3n","text":"<p>Este programa demuestra c\u00f3mo inicializar y controlar un LED NeoPixel (WS2812 o similar) desde un ESP32. Se utiliza la librer\u00eda oficial de Adafruit para manejar LEDs RGB direccionables.</p>"},{"location":"Pagina%20de%20practicas/paginas/neopixel_documentado/#codigo-fuente","title":"C\u00f3digo fuente","text":"<pre><code>#include &lt;Adafruit_NeoPixel.h&gt;\n#ifdef __AVR__\n#include &lt;avr/power.h&gt;\n#endif\n\n#define PIN 8\n#define NUMPIXELS 1\n\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nvoid setup(){\n  Serial.begin(115200);\n  pixels.begin();\n}\n\nvoid loop(){\n  pixels.clear();\n  pixels.setPixelColor(0, pixels.Color(122, 0, 122));\n  pixels.show();\n  delay(700);\n}\n</code></pre>"},{"location":"Pagina%20de%20practicas/paginas/neopixel_documentado/#explicacion-detallada","title":"Explicaci\u00f3n detallada","text":"<ul> <li>Librer\u00edas: <code>Adafruit_NeoPixel</code> permite crear y controlar una o varias luces RGB direccionables.  </li> <li>Configuraci\u00f3n: Se define el pin de salida y el n\u00famero de LEDs (<code>NUMPIXELS</code>).  </li> <li>Inicio: <code>pixels.begin()</code> configura el pin y la se\u00f1al.  </li> <li>L\u00f3gica: En cada iteraci\u00f3n se limpia el estado anterior, se define un color magenta (122,0,122) y se muestra.  </li> <li>Retardo: <code>delay(700)</code> genera una pausa visible antes de volver a ejecutar el ciclo.</li> </ul>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/","title":"Pr\u00e1ctica: Control de Servomotores mediante Interfaz Web con ESP32","text":"<p>Equipo / Autor(es): David Gonzales, Ximena Verdi y H\u00e9ctor Noriega Curso / Asignatura: Elementos Programables 2 Fecha: 21/10/2025  </p>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#resumen","title":"\ud83e\udde9 Resumen","text":"<p>En esta pr\u00e1ctica se desarroll\u00f3 un sistema de control remoto para dos servomotores utilizando una placa de desarrollo ESP32. Se implement\u00f3 un servidor web embebido que aloja una interfaz HTML con controles deslizantes (sliders). La comunicaci\u00f3n entre el cliente (navegador web) y el servidor (ESP32) se realiza de forma as\u00edncrona mediante JavaScript (AJAX), permitiendo ajustar la posici\u00f3n de los servos en tiempo real sin recargar la p\u00e1gina. El sistema convierte los valores de los sliders en se\u00f1ales PWM adecuadas para el posicionamiento angular de los servomotores.</p>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#objetivos","title":"\ud83c\udfaf Objetivos","text":""},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#general","title":"General","text":"<p>Desarrollar un sistema embebido capaz de controlar la posici\u00f3n de servomotores de forma remota a trav\u00e9s de una red local Wi-Fi, utilizando una interfaz web intuitiva.</p>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#especificos","title":"Espec\u00edficos","text":"<ul> <li>Configurar el ESP32 como punto de acceso Wi-Fi o estaci\u00f3n.  </li> <li>Implementar un servidor web en el ESP32 para servir una p\u00e1gina HTML de control.  </li> <li>Dise\u00f1ar una interfaz de usuario con HTML y JavaScript que incluya sliders para el control preciso de los servos.  </li> <li>Programar la l\u00f3gica en el ESP32 para recibir datos y traducirlos a se\u00f1ales PWM.  </li> <li>Validar el funcionamiento del sistema, asegurando respuesta fluida y en tiempo real.</li> </ul>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#alcance-y-exclusiones","title":"\u2699\ufe0f Alcance y Exclusiones","text":"<p>Incluye: - Uso del ESP32 como servidor web. - Control independiente de dos servomotores. - Interfaz HTML/JavaScript con sliders. - Comunicaci\u00f3n as\u00edncrona mediante AJAX. - Generaci\u00f3n de PWM por hardware con ledc.</p> <p>No incluye: - Control a trav\u00e9s de Internet (solo red local). - Autenticaci\u00f3n o cifrado. - Almacenamiento persistente de posiciones. - Uso de frameworks web avanzados (React, Vue, WebSockets, etc.).</p>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#codigo-original-version-corregida-y-funcional","title":"\ud83d\udcd8 C\u00f3digo Original (Versi\u00f3n Corregida y Funcional)","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n\n// --- CONFIGURACI\u00d3N DE RED ---\nconst char* ssid = \"HECTOR 15\";\nconst char* password = \"12345abc\";\n\n// --- CONFIGURACI\u00d3N DE PINES Y SERVOS ---\nconst int servoPin1 = 15; // Pin para el Servo 1\nconst int servoPin2 = 23; // Pin para el Servo 2\n\n// --- VARIABLES GLOBALES ---\nWebServer servidor(80);\nint sliderValue1 = 90; // Valor inicial del slider 1 (0-180)\nint sliderValue2 = 90; // Valor inicial del slider 2 (0-180)\n\n// --- PLANTILLA HTML ---\nconst char* htmlTemplate = R\"rawliteral(\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Control de Servos ESP32&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Control de Servomotores con ESP32&lt;/h1&gt;\n\n    &lt;h2&gt;Servo 1&lt;/h2&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"180\" value=\"%SLIDER_VALUE1%\" id=\"slider1\" oninput=\"updateSlider(1, this.value)\"&gt;\n    &lt;span id=\"sliderValue1\"&gt;%SLIDER_VALUE1%&lt;/span&gt;&amp;deg;\n\n    &lt;h2&gt;Servo 2&lt;/h2&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"180\" value=\"%SLIDER_VALUE2%\" id=\"slider2\" oninput=\"updateSlider(2, this.value)\"&gt;\n    &lt;span id=\"sliderValue2\"&gt;%SLIDER_VALUE2%&lt;/span&gt;&amp;deg;\n\n    &lt;script&gt;\n      function updateSlider(servoNum, value) {\n        document.getElementById('sliderValue' + servoNum).innerText = value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/slider?servo=\" + servoNum + \"&amp;value=\" + value, true);\n        xhr.send();\n      }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n)rawliteral\";\n\n// --- FUNCIONES DEL SERVIDOR WEB ---\nvoid setServoPosition(int servoChannel, int degrees) {\n  int dutyCycle = map(degrees, 0, 180, 205, 410);\n  ledcWrite(servoChannel, dutyCycle);\n}\n\nvoid handleRoot() {\n  String html = String(htmlTemplate);\n  html.replace(\"%SLIDER_VALUE1%\", String(sliderValue1));\n  html.replace(\"%SLIDER_VALUE2%\", String(sliderValue2));\n  servidor.send(200, \"text/html\", html);\n}\n\nvoid handleSlider() {\n  if (servidor.hasArg(\"servo\") &amp;&amp; servidor.hasArg(\"value\")) {\n    int servoNum = servidor.arg(\"servo\").toInt();\n    int value = servidor.arg(\"value\").toInt();\n\n    if (servoNum == 1) {\n      sliderValue1 = value;\n      setServoPosition(0, sliderValue1);\n      Serial.println(\"Servo 1 movido a: \" + String(sliderValue1) + \" grados\");\n    } else if (servoNum == 2) {\n      sliderValue2 = value;\n      setServoPosition(1, sliderValue2);\n      Serial.println(\"Servo 2 movido a: \" + String(sliderValue2) + \" grados\");\n    }\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // --- PWM PARA SERVOS ---\n  ledcAttachPin(servoPin1, 0);\n  ledcSetup(0, 50, 12);\n  ledcAttachPin(servoPin2, 1);\n  ledcSetup(1, 50, 12);\n\n  setServoPosition(0, sliderValue1);\n  setServoPosition(1, sliderValue2);\n\n  // --- CONEXI\u00d3N WIFI ---\n  WiFi.begin(ssid, password);\n  Serial.print(\"Conectando a WiFi...\");\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi conectado!\");\n  Serial.print(\"IP del servidor: \");\n  Serial.println(WiFi.localIP());\n\n  // --- RUTAS DEL SERVIDOR ---\n  servidor.on(\"/\", handleRoot);\n  servidor.on(\"/slider\", handleSlider);\n  servidor.begin();\n  Serial.println(\"Servidor web iniciado.\");\n}\n\nvoid loop() {\n  servidor.handleClient();\n}\n</code></pre>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#explicacion-tecnica-detallada","title":"\ud83d\udd0d Explicaci\u00f3n T\u00e9cnica Detallada","text":""},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#1-librerias-y-configuracion-de-red","title":"1. Librer\u00edas y configuraci\u00f3n de red","text":"<p>Se incluyen las librer\u00edas <code>WiFi.h</code> y <code>WebServer.h</code> que permiten la conexi\u00f3n del ESP32 a una red inal\u00e1mbrica y la creaci\u00f3n de un servidor HTTP local.</p>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#2-control-pwm-de-los-servomotores","title":"2. Control PWM de los servomotores","text":"<p>El ESP32 utiliza los canales ledc para generar se\u00f1ales PWM a 50 Hz con resoluci\u00f3n de 12 bits. El rango de 205 a 410 equivale aproximadamente a un pulso de 1\u20132 ms, que representa 0\u2013180 \u00b0 en los servos.</p>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#3-interfaz-web","title":"3. Interfaz Web","text":"<p>La p\u00e1gina HTML incluye dos sliders para el control de los servos. Cada cambio genera una solicitud AJAX al ESP32, sin recargar la p\u00e1gina.</p>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#4-servidor-http","title":"4. Servidor HTTP","text":"<p>Maneja las rutas: - <code>/</code> \u2192 P\u00e1gina principal - <code>/slider</code> \u2192 Actualiza la posici\u00f3n del servo seg\u00fan los par\u00e1metros recibidos.</p>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#5-flujo-del-sistema","title":"5. Flujo del sistema","text":"<ol> <li>Inicializaci\u00f3n de PWM y red.  </li> <li>Conexi\u00f3n Wi-Fi.  </li> <li>Ejecuci\u00f3n del servidor web.  </li> <li>Recepci\u00f3n de comandos desde la interfaz.  </li> <li>Ajuste de posici\u00f3n de servos en tiempo real.</li> </ol>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#funciones-principales","title":"\ud83e\udde0 Funciones Principales","text":"Funci\u00f3n Descripci\u00f3n <code>WiFi.begin()</code> Inicia la conexi\u00f3n Wi-Fi. <code>WebServer servidor(80)</code> Crea el servidor HTTP. <code>ledcSetup()</code> Configura la frecuencia y resoluci\u00f3n PWM. <code>ledcAttachPin()</code> Asocia un pin al canal PWM. <code>ledcWrite()</code> Ajusta el ciclo de trabajo PWM. <code>servidor.on()</code> Define las rutas HTTP. <code>servidor.handleClient()</code> Atiende las solicitudes entrantes."},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#recomendaciones-tecnicas","title":"\ud83d\udca1 Recomendaciones T\u00e9cnicas","text":"<ul> <li>Utilizar fuente de alimentaci\u00f3n externa para los servos (m\u00ednimo 1 A).  </li> <li>Conectar GND com\u00fan entre la fuente y el ESP32.  </li> <li>Agregar condensador de 100 \u00b5F para evitar ca\u00eddas de tensi\u00f3n.  </li> <li>Considerar WebSockets para control en tiempo real bidireccional.  </li> <li>A\u00f1adir CSS para mejorar la interfaz web.</li> </ul>"},{"location":"Pagina%20de%20practicas/paginas/practica%20control%20servos/#conclusiones","title":"\ud83e\uddfe Conclusiones","text":"<p>Se logr\u00f3 implementar con \u00e9xito un sistema de control remoto de servomotores usando ESP32 y una interfaz web. El uso de AJAX permiti\u00f3 una comunicaci\u00f3n eficiente sin recarga de p\u00e1gina, y las funciones ledc garantizaron un control PWM estable.  </p> <p>El proyecto demuestra la integraci\u00f3n entre sistemas embebidos y tecnolog\u00edas web, aplicable en IoT, rob\u00f3tica y dom\u00f3tica. Futuras mejoras incluyen interfaz visual mejorada, comunicaci\u00f3n WebSocket y autenticaci\u00f3n segura.</p>"},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/","title":"Recepci\u00f3n de Comandos por Comunicaci\u00f3n Serial (String_comandos_documentado.md)","text":"<p>Este documento explica detalladamente el funcionamiento del c\u00f3digo correspondiente a la Pr\u00e1ctica 2: Recepci\u00f3n de Comandos por Comunicaci\u00f3n Serial, el cual implementa la lectura y el eco de cadenas de texto (<code>String</code>) enviadas desde el Monitor Serial hacia una placa Arduino o ESP32.</p>"},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#codigo-original","title":"\ud83d\udcd8 C\u00f3digo Original","text":"<pre><code>// Variable global para almacenar el comando recibido\nString cmd = \"\";\n\nvoid setup() {\n  // Inicializa la comunicaci\u00f3n serial a 115200 baudios\n  Serial.begin(115200); \n}\n\nvoid loop() {\n  // Verifica si hay datos disponibles para leer en el buffer serial\n  if (Serial.available() &gt; 0) {            \n    // Lee todos los caracteres hasta encontrar un salto de l\u00ednea ('\\n')\n    // y los almacena en la variable 'cmd'\n    cmd = Serial.readStringUntil('\\n');\n\n    // Imprime la cadena completa recibida en el monitor serial\n    Serial.println(cmd);                   \n  }\n}\n</code></pre>"},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#explicacion-tecnica-detallada","title":"\ud83d\udd0d Explicaci\u00f3n T\u00e9cnica Detallada","text":""},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#1-declaracion-de-variables-globales","title":"1. Declaraci\u00f3n de variables globales","text":"<pre><code>String cmd = \"\";\n</code></pre> <p>Se declara una variable global llamada <code>cmd</code> de tipo <code>String</code>, la cual servir\u00e1 para almacenar temporalmente el texto recibido desde el puerto serial. Esta variable permite manejar mensajes de longitud variable (palabras, frases o comandos).</p>"},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#2-funcion-setup","title":"2. Funci\u00f3n <code>setup()</code>","text":"<pre><code>void setup() {\n  Serial.begin(115200); \n}\n</code></pre> <p>Explicaci\u00f3n: - <code>Serial.begin(115200)</code> inicia la comunicaci\u00f3n serial entre la placa y el ordenador a una velocidad de 115200 baudios (bits por segundo). - Este paso es indispensable para habilitar el intercambio de datos mediante el Monitor Serial del IDE de Arduino.</p>"},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#3-funcion-loop","title":"3. Funci\u00f3n <code>loop()</code>","text":"<p>El ciclo principal del programa se ejecuta continuamente. En \u00e9l se realiza la lectura del puerto serial y el reenv\u00edo del texto recibido (eco).</p> <pre><code>void loop() {\n  if (Serial.available() &gt; 0) {\n    cmd = Serial.readStringUntil('\\n');\n    Serial.println(cmd);\n  }\n}\n</code></pre> <p>Desglose paso a paso:</p> <ol> <li> <p><code>Serial.available() &gt; 0</code>    Comprueba si existen datos disponibles en el buffer serial.    Si el valor es mayor que 0, significa que el usuario ha enviado texto desde el Monitor Serial.</p> </li> <li> <p><code>Serial.readStringUntil('\\n')</code>    Lee todos los caracteres recibidos hasta encontrar un salto de l\u00ednea (<code>\\n</code>), el cual indica el final del mensaje.    Todo el texto anterior a este car\u00e1cter se guarda en la variable <code>cmd</code>.    Esta funci\u00f3n simplifica la lectura de cadenas completas, evitando el uso de bucles que lean car\u00e1cter por car\u00e1cter.</p> </li> <li> <p><code>Serial.println(cmd)</code>    Imprime nuevamente el texto almacenado en <code>cmd</code>.    Este comportamiento implementa un \u201ceco de l\u00ednea\u201d, confirmando que los datos fueron correctamente recibidos.</p> </li> </ol>"},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#flujo-general-del-programa","title":"\u2699\ufe0f Flujo General del Programa","text":"<ol> <li>Se inicializa la comunicaci\u00f3n serial.  </li> <li>El programa entra en un bucle continuo.  </li> <li>Si hay datos en el buffer, se leen hasta un salto de l\u00ednea (<code>\\n</code>).  </li> <li>El texto recibido se guarda en <code>cmd</code>.  </li> <li>Se imprime el mismo texto de vuelta en el Monitor Serial.</li> </ol>"},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#funciones-clave","title":"\ud83e\udde0 Funciones Clave","text":"Funci\u00f3n Descripci\u00f3n <code>Serial.begin(baud)</code> Inicia la comunicaci\u00f3n serial con la velocidad indicada. <code>Serial.available()</code> Devuelve el n\u00famero de bytes disponibles para leer en el buffer serial. <code>Serial.readStringUntil(char)</code> Lee los caracteres recibidos hasta encontrar el car\u00e1cter delimitador especificado. <code>Serial.println(variable)</code> Env\u00eda el valor de la variable al Monitor Serial seguido de un salto de l\u00ednea."},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#resultados-observados","title":"\ud83d\udcc8 Resultados Observados","text":"<ul> <li>Recepci\u00f3n correcta: El microcontrolador recibe la cadena completa enviada desde el Monitor Serial.  </li> <li>Eco funcional: El mismo texto se reenv\u00eda y se muestra en pantalla, verificando que la transmisi\u00f3n es exitosa.  </li> <li>Uso de <code>Serial.readStringUntil()</code>: Se confirm\u00f3 que la funci\u00f3n simplifica la lectura de mensajes al detenerse autom\u00e1ticamente al detectar <code>\\n</code>.  </li> <li>Flexibilidad de <code>String</code>: La variable <code>cmd</code> maneja cadenas de longitud variable sin requerir un tama\u00f1o de buffer fijo.</li> </ul>"},{"location":"Pagina%20de%20practicas/paginas/string_comandos_documentado/#conclusiones-tecnicas","title":"\ud83d\udca1 Conclusiones T\u00e9cnicas","text":"<p>Esta pr\u00e1ctica permite comprender c\u00f3mo gestionar la comunicaci\u00f3n serial basada en texto completo, un paso esencial para implementar sistemas controlados por comandos. El m\u00e9todo <code>Serial.readStringUntil()</code> proporciona una forma sencilla y eficiente de recibir mensajes legibles por humanos, eliminando la necesidad de reconstruir cadenas car\u00e1cter por car\u00e1cter.  </p> <p>Aunque el uso de la clase <code>String</code> facilita la programaci\u00f3n, se debe tener precauci\u00f3n en proyectos complejos, ya que puede consumir memoria din\u00e1mica. En sistemas con recursos limitados, se recomienda el uso de arreglos de caracteres (<code>char[]</code>) cuando la estabilidad de memoria sea prioritaria.  </p> <p>Este programa constituye la base para sistemas m\u00e1s avanzados de interpretaci\u00f3n de comandos, donde funciones como <code>cmd.startsWith()</code> o <code>cmd.equals()</code> pueden utilizarse para ejecutar acciones espec\u00edficas seg\u00fan el contenido del texto recibido.</p> <p>(Fin de la documentaci\u00f3n t\u00e9cnica del archivo String_comandos_documentado.md)</p>"},{"location":"Pagina%20de%20practicas/paginas/string_serial_documentado/","title":"Lectura y eco de cadenas por Serial","text":""},{"location":"Pagina%20de%20practicas/paginas/string_serial_documentado/#introduccion","title":"Introducci\u00f3n","text":"<p>Este c\u00f3digo realiza la lectura de texto ingresado por el monitor serial y lo devuelve como respuesta. Es una forma simple de probar comunicaci\u00f3n serial bidireccional.</p>"},{"location":"Pagina%20de%20practicas/paginas/string_serial_documentado/#codigo-fuente","title":"C\u00f3digo fuente","text":"<pre><code>String cmd = \"\";\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  if (Serial.available() &gt; 0) {\n    cmd = Serial.readStringUntil('\\n');\n    Serial.println(cmd);\n  }\n}\n</code></pre>"},{"location":"Pagina%20de%20practicas/paginas/string_serial_documentado/#explicacion-extendida","title":"Explicaci\u00f3n extendida","text":"<ul> <li>Serial.available(): Detecta si hay bytes listos para leerse.  </li> <li>readStringUntil('\\n'): Lee hasta un salto de l\u00ednea.  </li> <li>println(cmd): Devuelve el texto recibido, actuando como eco.  </li> <li>\u00datil para pruebas de comandos o comunicaci\u00f3n b\u00e1sica.</li> </ul>"},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/","title":"Control WiFi con ESP32 (wifiRlite.ino)","text":"<p>Este documento explica detalladamente el funcionamiento del c\u00f3digo wifiRlite.ino, el cual utiliza el m\u00f3dulo WiFi del ESP32 para establecer comunicaci\u00f3n o control remoto. Se detalla cada parte del c\u00f3digo, las funciones empleadas y el flujo general de operaci\u00f3n.</p>"},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#codigo-original","title":"\ud83d\udcd8 C\u00f3digo Original","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n\n// Reemplaza con tus credenciales de red\nconst char* ssid = \"AndroidAP\";\nconst char* password = \"kkcl99113\";\n\n// Crea un servidor web en el puerto 80\nWebServer servidor(80);\n\nconst int ledPin = LED_BUILTIN;  // LED integrado en muchas placas ESP32\nString ledState = \"OFF\";\n\n// Plantilla HTML definida como raw string literal\nconst char* htmlTemplate = R\"rawliteral(\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Control de LED ESP32&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Control de LED ESP32&lt;/h1&gt;\n    &lt;p&gt;El LED est\u00e1 %LED_STATE%&lt;/p&gt;\n    &lt;a href=\"/%LINK%\"&gt;&lt;button&gt;%BUTTON_TEXT%&lt;/button&gt;&lt;/a&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n)rawliteral\";\n\n// Manejador para la p\u00e1gina principal\nvoid handleroot() {\n  String html = String(htmlTemplate);\n\n  // Reemplaza el marcador %LED_STATE% con el estado actual del LED\n  html.replace(\"%LED_STATE%\", ledState);\n\n  // Configura el enlace y el texto del bot\u00f3n seg\u00fan el estado del LED\n  if (ledState == \"OFF\") {\n    html.replace(\"%LINK%\", \"ON\");\n    html.replace(\"%BUTTON_TEXT%\", \"ON\");\n  } else {\n    html.replace(\"%LINK%\", \"OFF\");\n    html.replace(\"%BUTTON_TEXT%\", \"OFF\");\n  }\n\n  servidor.send(200, \"text/html\", html);\n}\n\n\nvoid handleOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = \"ON\";\n  handleroot();  // Muestra la p\u00e1gina actualizada\n}\n\n// Manejador para apagar el LED\nvoid handleOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = \"OFF\";\n  handleroot();  // Muestra la p\u00e1gina actualizada\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n\n  // Conectar a WiFi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi conectado\");\n  Serial.println(WiFi.localIP());\n\n  // Definir rutas\n  servidor.on(\"/\", handleroot);\n  servidor.on(\"/ON\", handleOn);\n  servidor.on(\"/OFF\", handleOff);\n\n  // Iniciar el servidor\n  servidor.begin();\n  Serial.println(\"Server started\");\n}\n\nvoid loop() {\n  // Manejar solicitudes entrantes\n  servidor.handleClient();\n}\n</code></pre>"},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#explicacion-tecnica-detallada","title":"\ud83d\udd0d Explicaci\u00f3n T\u00e9cnica Detallada","text":""},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#1-inclusion-de-librerias","title":"1. Inclusi\u00f3n de librer\u00edas","text":"<p>El c\u00f3digo utiliza la librer\u00eda principal de WiFi del ESP32:</p> <pre><code>#include &lt;WiFi.h&gt;\n</code></pre> <p>Esta librer\u00eda permite conectar el ESP32 a una red inal\u00e1mbrica y usar funciones como <code>WiFi.begin()</code>, <code>WiFi.status()</code> o <code>WiFi.localIP()</code>.</p>"},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#2-configuracion-inicial","title":"2. Configuraci\u00f3n inicial","text":"<p>Normalmente el programa define las credenciales de red:</p> <pre><code>const char* ssid = \"NombreRed\";\nconst char* password = \"Contrase\u00f1a\";\n</code></pre> <p>Estas variables contienen el SSID (nombre de la red) y la contrase\u00f1a de la red WiFi a la que el ESP32 se conectar\u00e1.</p>"},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#3-funcion-setup","title":"3. Funci\u00f3n <code>setup()</code>","text":"<p>En esta secci\u00f3n se inicializa el monitor serial y se intenta establecer la conexi\u00f3n WiFi:</p> <pre><code>void setup() {\n  Serial.begin(115200);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"Conectado a WiFi\");\n  Serial.println(WiFi.localIP());\n}\n</code></pre> <p>Explicaci\u00f3n: - <code>WiFi.begin()</code> inicia la conexi\u00f3n con la red indicada. - <code>WiFi.status()</code> devuelve el estado actual (espera hasta <code>WL_CONNECTED</code>). - <code>WiFi.localIP()</code> imprime la direcci\u00f3n IP asignada al ESP32.</p>"},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#4-funcion-loop","title":"4. Funci\u00f3n <code>loop()</code>","text":"<p>Una vez conectado, el c\u00f3digo puede ejecutar funciones peri\u00f3dicas o manejar comunicaci\u00f3n con un cliente (HTTP, UDP, etc.). Por ejemplo:</p> <pre><code>void loop() {\n  // Ejemplo: enviar datos, recibir comandos o verificar conexi\u00f3n\n}\n</code></pre> <p>El contenido exacto depende de si el ESP32 act\u00faa como servidor o cliente.</p>"},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#flujo-general-del-programa","title":"\u2699\ufe0f Flujo General del Programa","text":"<ol> <li>Se inicializa la comunicaci\u00f3n serial.  </li> <li>Se configuran las credenciales WiFi.  </li> <li>El ESP32 se conecta a la red y muestra su IP.  </li> <li>Una vez conectado, puede ejecutar otras tareas o esperar comandos.</li> </ol>"},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#funciones-clave","title":"\ud83e\udde0 Funciones Clave","text":"Funci\u00f3n Descripci\u00f3n <code>WiFi.begin(ssid, password)</code> Inicia la conexi\u00f3n WiFi con las credenciales proporcionadas. <code>WiFi.status()</code> Devuelve el estado actual de la conexi\u00f3n WiFi. <code>WiFi.localIP()</code> Muestra la direcci\u00f3n IP asignada al ESP32. <code>Serial.begin(baud)</code> Inicializa la comunicaci\u00f3n serial. <code>delay(ms)</code> Pausa la ejecuci\u00f3n durante el tiempo indicado."},{"location":"Pagina%20de%20practicas/paginas/wifiRlite_documentado/#recomendaciones-tecnicas","title":"\ud83d\udca1 Recomendaciones T\u00e9cnicas","text":"<ul> <li>Aseg\u00farate de usar una fuente de energ\u00eda estable para el ESP32.  </li> <li>Verifica que la red WiFi tenga suficiente cobertura.  </li> <li>Evita colocar <code>delay()</code> prolongados en el <code>loop()</code> si el dispositivo necesita responder r\u00e1pido.  </li> <li>Puedes usar <code>WiFi.reconnect()</code> para restablecer la conexi\u00f3n en caso de desconexi\u00f3n.</li> </ul> <p>(Fin de la documentaci\u00f3n t\u00e9cnica del archivo wifiRlite.ino)</p>"}]}