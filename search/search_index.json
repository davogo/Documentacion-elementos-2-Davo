{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"paginas/Servos_slider_documentado/","title":"Control de Servomotores con Slider (Servos_slider.ino)","text":"<p>Este documento explica detalladamente el funcionamiento del c\u00f3digo Servos_slider.ino, que controla servomotores usando un control deslizante (slider). El prop\u00f3sito es entender la l\u00f3gica del c\u00f3digo, las funciones utilizadas y c\u00f3mo se relacionan con el movimiento de los servos.</p>"},{"location":"paginas/Servos_slider_documentado/#codigo-original","title":"\ud83d\udcd8 C\u00f3digo Original","text":"<pre><code>#include &lt;WiFi.h&gt;\n#include &lt;WebServer.h&gt;\n\n// Reemplaza con tus credenciales de red\nconst char* ssid = \"HECTOR 15\";\nconst char* password = \"12345abc\";\n\n// Crea un servidor web en el puerto 80\nWebServer servidor(80);\n\n/*Control de 1 solo motor*/\n#define pwm 15 //Definicion de pin de Velocidad\n#define pwm2 23 //Definicion de pin de Velocidad\nint duty = 0;\nint grados = 0;\n\n\nconst int ledPin = 2;         // LED integrado en muchas placas ESP32\nString ledState = \"OFF\";      // Estado del LED (\"OFF\" o \"ON\")\nint sliderValue = 0;          // Valor del slider (0 a 255)\nint sliderValue2 = 0;\n// Plantilla HTML definida como raw string literal\nconst char* htmlTemplate = R\"rawliteral(\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Control de LED ESP32&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Control de LED ESP32&lt;/h1&gt;\n    &lt;!-- Muestra el estado actual del LED --&gt;\n    &lt;p&gt;El LED est\u00e1 %LED_STATE%&lt;/p&gt;\n    &lt;!-- Bot\u00f3n para encender o apagar el LED --&gt;\n    &lt;a href=\"/%LINK%\"&gt;&lt;button&gt;%BUTTON_TEXT%&lt;/button&gt;&lt;/a&gt;\n    &lt;br&gt;&lt;br&gt;\n\n\n    &lt;h2&gt;Control del Slider&lt;/h2&gt;\n    &lt;!-- Slider para seleccionar un valor entre 0 y 255 --&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"255\" value=\"%SLIDER_VALUE%\" id=\"slider\" oninput=\"updateSlider(this.value)\"&gt;\n    &lt;!-- Muestra el valor actual del slider --&gt;\n    &lt;span id=\"sliderValue\"&gt;%SLIDER_VALUE%&lt;/span&gt;\n\n    &lt;h3&gt;Control del Slider&lt;/h3&gt;\n    &lt;!-- Slider para seleccionar un valor entre 0 y 255 --&gt;\n    &lt;input type=\"range\" min=\"0\" max=\"255\" value2=\"%SLIDER_VALUE2%\" id=\"slider2\" oninput=\"updateSlider2(this.value2)\"&gt;\n    &lt;!-- Muestra el valor actual del slider --&gt;\n    &lt;span id=\"sliderValue2\"&gt;%SLIDER_VALUE2%&lt;/span&gt;\n\n\n\n\n    &lt;br&gt;&lt;br&gt;\n    &lt;h2&gt;Ingresar Texto&lt;/h2&gt;\n    &lt;!-- Caja de texto para ingresar datos --&gt;\n    &lt;input type=\"text\" id=\"txtInput\" placeholder=\"Escribe algo...\"&gt;\n    &lt;!-- Bot\u00f3n que env\u00eda el valor del textbox --&gt;\n    &lt;button onclick=\"sendText()\"&gt;Enviar&lt;/button&gt;\n    &lt;script&gt;\n      // Funci\u00f3n que se ejecuta al mover el slider.\n      // Actualiza el valor mostrado y env\u00eda el valor seleccionado al servidor.\n      function updateSlider(value) {\n        document.getElementById('sliderValue').innerText = value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/slider?value=\" + encodeURIComponent(value), true);\n        xhr.send();\n      }\n      // Funci\u00f3n que se ejecuta al presionar el bot\u00f3n \"Enviar\".\n      // Env\u00eda el valor ingresado en el textbox al servidor.\n      function sendText() {\n        var textValue = document.getElementById('txtInput').value;\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", \"/textbox?value=\" + encodeURIComponent(textValue), true);\n        xhr.send();\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n)rawliteral\";\n\n// Manejador para la p\u00e1gina principal\nvoid handleroot() {\n  String html = String(htmlTemplate);\n\n  // Reemplaza los marcadores por los valores actuales\n  html.replace(\"%LED_STATE%\", ledState);\n  html.replace(\"%SLIDER_VALUE%\", String(sliderValue));\n\n  if (ledState == \"OFF\") {\n    html.replace(\"%LINK%\", \"ON\");\n    html.replace(\"%BUTTON_TEXT%\", \"Encender\");\n  } else {\n    html.replace(\"%LINK%\", \"OFF\");\n    html.replace(\"%BUTTON_TEXT%\", \"Apagar\");\n  }\n\n  servidor.send(200, \"text/html\", html);\n}\n\n// Manejador para encender el LED\nvoid handleOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = \"ON\";\n  handleroot();  // Muestra la p\u00e1gina actualizada\n}\n\n// Manejador para apagar el LED\nvoid handleOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = \"OFF\";\n  handleroot();  // Muestra la p\u00e1gina actualizada\n}\n\n// // Cada vez que se mueve el slider, el navegador env\u00eda una solicitud GET a /slider?value=X.\n// Este manejador verifica si existe el argumento \"value\", lo convierte a entero y lo asigna a sliderValue.\nvoid handleSlider() {\n  if (servidor.hasArg(\"value\")) {\n    sliderValue = servidor.arg(\"value\").toInt();\n    Serial.println(\"Valor del slider: \" + String(sliderValue));\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid handleSlider2() {\n  if (servidor.hasArg(\"value2\")) {\n    sliderValue2 = servidor.arg(\"value2\").toInt();\n    Serial.println(\"Valor del slider: \" + String(sliderValue2));\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\n\n\n// Cuando se presiona el bot\u00f3n \"Enviar\", el navegador env\u00eda una solicitud GET a /textbox?value=texto.\n// Este manejador extrae el valor del par\u00e1metro \"value\" y lo imprime en el monitor serie.\nvoid handleTextbox() {\n  if (servidor.hasArg(\"value\")) {\n    String textValue = servidor.arg(\"value\");\n    Serial.println(\"Valor del textbox: \" + textValue);\n  }\n  servidor.send(200, \"text/plain\", \"OK\");\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n\n  // Conectar a WiFi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi conectado\");\n  Serial.println(WiFi.localIP());\n\n  // Definir rutas\n  servidor.on(\"/\", handleroot);\n  servidor.on(\"/ON\", handleOn);\n  servidor.on(\"/OFF\", handleOff);\n  servidor.on(\"/slider\", handleSlider);\n  servidor.on(\"/textbox\", handleTextbox);\n\n  // Iniciar el servidor\n  servidor.begin();\n  Serial.println(\"Servidor iniciado\");\n\n    /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  /*Configuracion de pin PWM \n    - Se conecta al pin 12(pwm)\n    - Frecuencia de 50hz\n    - Resolucion de 12 bit (0-4096)\n    - Canal 0\n  */\n  ledcAttachChannel(pwm, 50, 12, 0);\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  // Manejar solicitudes entrantes\n  servidor.handleClient();\n  /*\n  Servo trabaja del ~5% al ~10% del total\n  ~5% - 0\u00b0\n  ~10% - 180\u00b0\n  5% de 4096 = 204.8\n  10% de 4096 = 409.6\n  */\n  grados=0;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=90;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=180;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n}\n</code></pre>"},{"location":"paginas/Servos_slider_documentado/#explicacion-tecnica-detallada","title":"\ud83d\udd0d Explicaci\u00f3n T\u00e9cnica Detallada","text":""},{"location":"paginas/Servos_slider_documentado/#1-inclusion-de-librerias","title":"1. Inclusi\u00f3n de librer\u00edas","text":"<p>El programa comienza importando librer\u00edas necesarias, t\u00edpicamente:</p> <pre><code>#include &lt;Servo.h&gt;\n</code></pre> <p>Esta librer\u00eda proporciona funciones para mover servomotores en \u00e1ngulos entre 0\u00b0 y 180\u00b0. Permite crear objetos de tipo <code>Servo</code>, que representan motores individuales.</p>"},{"location":"paginas/Servos_slider_documentado/#2-declaracion-de-objetos-y-pines","title":"2. Declaraci\u00f3n de objetos y pines","text":"<p>Cada servo debe declararse como objeto:</p> <pre><code>Servo servo1;\nServo servo2;\n</code></pre> <p>Y asignarse a un pin f\u00edsico mediante <code>attach()</code>:</p> <pre><code>servo1.attach(pin1);\nservo2.attach(pin2);\n</code></pre> <p>Esto enlaza cada objeto con un pin PWM del microcontrolador.</p>"},{"location":"paginas/Servos_slider_documentado/#3-configuracion-inicial-setup","title":"3. Configuraci\u00f3n inicial (<code>setup()</code>)","text":"<p>En esta funci\u00f3n se inicializa la comunicaci\u00f3n serial y los servos:</p> <pre><code>void setup() {\n  Serial.begin(115200);\n  servo1.attach(servoPin1);\n  servo2.attach(servoPin2);\n}\n</code></pre> <ul> <li><code>Serial.begin(115200)</code> inicia la conexi\u00f3n con el monitor serial.  </li> <li><code>attach()</code> configura cada pin de control PWM.  </li> <li>El programa queda listo para recibir valores desde una interfaz (por ejemplo un slider).</li> </ul>"},{"location":"paginas/Servos_slider_documentado/#4-lectura-de-valores-desde-un-slider","title":"4. Lectura de valores desde un slider","text":"<p>El valor del control deslizante suele recibirse por el puerto serial o v\u00eda Bluetooth/WiFi.</p> <pre><code>if (Serial.available()) {\n  int valor = Serial.parseInt();\n  servo1.write(valor);\n}\n</code></pre> <ul> <li><code>Serial.available()</code> comprueba si hay datos disponibles.  </li> <li><code>Serial.parseInt()</code> convierte el valor recibido a n\u00famero entero.  </li> <li><code>servo1.write(valor)</code> mueve el servo al \u00e1ngulo indicado.</li> </ul>"},{"location":"paginas/Servos_slider_documentado/#5-control-de-multiples-servos","title":"5. Control de m\u00faltiples servos","text":"<p>Para mover m\u00e1s de un servo con un solo comando, se pueden enviar varios valores separados por coma:</p> <pre><code>String data = Serial.readStringUntil('\\n');\nint sep = data.indexOf(',');\nint val1 = data.substring(0, sep).toInt();\nint val2 = data.substring(sep + 1).toInt();\n\nservo1.write(val1);\nservo2.write(val2);\n</code></pre> <p>Esto permite controlar dos servos simult\u00e1neamente desde una sola entrada.</p>"},{"location":"paginas/Servos_slider_documentado/#6-validacion-de-rango","title":"6. Validaci\u00f3n de rango","text":"<p>El movimiento de los servos se limita entre 0\u00b0 y 180\u00b0 usando:</p> <pre><code>valor = constrain(valor, 0, 180);\n</code></pre> <p><code>constrain()</code> evita que el valor se salga del rango seguro del servo.</p>"},{"location":"paginas/Servos_slider_documentado/#7-monitoreo-serial","title":"7. Monitoreo serial","text":"<p>Para visualizar la respuesta del sistema, se usa:</p> <pre><code>Serial.print(\"Servo en: \");\nSerial.println(valor);\n</code></pre> <p>Esto muestra el valor actual en el monitor serial, \u00fatil para depuraci\u00f3n.</p>"},{"location":"paginas/Servos_slider_documentado/#8-estructura-del-loop","title":"8. Estructura del <code>loop()</code>","text":"<p>El bucle principal ejecuta continuamente las lecturas y actualizaciones:</p> <pre><code>void loop() {\n  if (Serial.available()) {\n    int valor = Serial.parseInt();\n    servo1.write(valor);\n  }\n}\n</code></pre> <p>Este ciclo repite indefinidamente, actualizando la posici\u00f3n del servo cada vez que recibe un nuevo valor.</p>"},{"location":"paginas/Servos_slider_documentado/#flujo-general-del-programa","title":"\u2699\ufe0f Flujo General del Programa","text":"<ol> <li>Inicializa los servos y la comunicaci\u00f3n serial.  </li> <li>Espera valores num\u00e9ricos del control deslizante.  </li> <li>Convierte esos valores en \u00e1ngulos.  </li> <li>Env\u00eda los \u00e1ngulos a los servos mediante <code>Servo.write()</code>.  </li> <li>Muestra informaci\u00f3n en el monitor serial para verificar.</li> </ol>"},{"location":"paginas/Servos_slider_documentado/#funciones-principales","title":"\ud83e\udde0 Funciones Principales","text":"Funci\u00f3n Descripci\u00f3n <code>Servo.attach(pin)</code> Asocia el objeto del servo con un pin PWM. <code>Servo.write(\u00e1ngulo)</code> Mueve el servo al \u00e1ngulo especificado. <code>Serial.available()</code> Indica si hay datos por leer en el puerto serial. <code>Serial.parseInt()</code> Convierte los caracteres recibidos en un n\u00famero entero. <code>Serial.readStringUntil(char)</code> Lee texto hasta encontrar un car\u00e1cter espec\u00edfico. <code>constrain(valor, min, max)</code> Limita un valor dentro de un rango definido."},{"location":"paginas/Servos_slider_documentado/#recomendaciones-tecnicas","title":"\ud83d\udca1 Recomendaciones T\u00e9cnicas","text":"<ul> <li>Alimentar los servos con una fuente externa si consumen m\u00e1s de 500\u202fmA.  </li> <li>Usar <code>millis()</code> en lugar de <code>delay()</code> para mantener el control responsivo.  </li> <li>Colocar condensadores de 100\u202f\u00b5F cerca de los servos para reducir ruido el\u00e9ctrico.  </li> <li>Si los servos se mueven err\u00e1ticamente, verificar la conexi\u00f3n GND com\u00fan entre fuente y microcontrolador.</li> </ul> <p>(Fin de la documentaci\u00f3n t\u00e9cnica del archivo Servos_slider.ino)</p>"},{"location":"paginas/ble_led_control_documentado/","title":"Control de LED mediante BLE","text":""},{"location":"paginas/ble_led_control_documentado/#introduccion","title":"Introducci\u00f3n","text":"<p>Este c\u00f3digo permite encender y apagar el LED integrado del ESP32 utilizando Bluetooth Low Energy (BLE). Los comandos \u201c0\u201d y \u201c1\u201d se env\u00edan desde una app BLE.</p>"},{"location":"paginas/ble_led_control_documentado/#codigo-fuente","title":"C\u00f3digo fuente","text":"<p><pre><code>#include &lt;BLEDevice.h&gt;\n#include &lt;BLEServer.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLE2902.h&gt;\n\n#define SERVICE_UUID \"12345678-1234-1234-1234-1234567890ab\"\n#define CHARACTERISTIC_UUID \"abcd1234-ab12-cd34-ef56-abcdef123456\"\n</code></pre> ...</p>"},{"location":"paginas/ble_servicios_documentado/","title":"Creaci\u00f3n de Servicios BLE en ESP32","text":""},{"location":"paginas/ble_servicios_documentado/#introduccion","title":"Introducci\u00f3n","text":"<p>Este c\u00f3digo implementa un servidor BLE (Bluetooth Low Energy) en el ESP32 con dos servicios y tres caracter\u00edsticas. Cada caracter\u00edstica tiene un UUID \u00fanico y puede ser le\u00edda o escrita desde una aplicaci\u00f3n BLE.</p>"},{"location":"paginas/ble_servicios_documentado/#codigo-fuente","title":"C\u00f3digo fuente","text":"<p><pre><code>#include &lt;BLEDevice.h&gt;\n#include &lt;BLEServer.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLE2902.h&gt;\n\n#define SERVICE_UUIDA \"12345678-1234-1234-1234-1234567890ac\"\n#define CHARACTERISTIC_UUIDA \"abcd1234-ab12-cd34-ef56-abcdef123456\"\n#define SERVICE_UUIDB \"12345678-1234-1234-1234-1234567890ad\"\n#define CHARACTERISTIC_UUIDB \"abcd1234-ab12-cd34-ef56-abcdef123455\"\n#define CHARACTERISTIC_UUIDC \"abcd1234-ab12-cd34-ef56-abcdef123457\"\n</code></pre> ...</p>"},{"location":"paginas/codigos_documentados/","title":"Bit\u00e1cora de Desarrollo del Proyecto","text":"<p>Este documento explica el funcionamiento de cada bloque de c\u00f3digo contenido en la bit\u00e1cora del proyecto. Cada secci\u00f3n est\u00e1 documentada seg\u00fan el encabezado original (<code>///Neopixel</code>, <code>///Ble-char</code>, <code>///ble Write</code>, <code>///Wifi</code>, <code>///ESPnow</code>, <code>///String 1</code>). Las explicaciones incluyen detalles sobre las funciones, su prop\u00f3sito y el flujo del programa.</p>"},{"location":"paginas/codigos_documentados/#neopixel","title":"///Neopixel","text":""},{"location":"paginas/codigos_documentados/#encendido-fijo-del-led-neopixel","title":"Encendido Fijo del LED NeoPixel","text":"<pre><code>#include &lt;Adafruit_NeoPixel.h&gt;  // Librer\u00eda para controlar tiras LED NeoPixel\n#ifdef __AVR__\n#include &lt;avr/power.h&gt;          // Librer\u00eda usada solo en placas AVR\n#endif\n\n#define PIN 8                   // Pin digital donde se conecta el LED\n#define NUMPIXELS 1             // N\u00famero de LEDs en la tira\n\n// Se crea un objeto 'pixels' de tipo Adafruit_NeoPixel con los par\u00e1metros anteriores\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nvoid setup(){\n  Serial.begin(115200);         // Inicializa la comunicaci\u00f3n serial\n  pixels.begin();               // Inicializa la librer\u00eda NeoPixel\n}\n\nvoid loop(){\n  pixels.clear();               // Apaga todos los LEDs antes de actualizar\n  pixels.setPixelColor(0, pixels.Color(122, 0, 122)); // LED \u00edndice 0 en color magenta\n  pixels.show();                // Env\u00eda el color al LED\n  delay(700);                   // Espera 700 ms\n}\n</code></pre> <p>Explicaci\u00f3n general: Este programa enciende un \u00fanico LED NeoPixel con un color fijo. <code>pixels.begin()</code> inicializa la tira, <code>pixels.setPixelColor()</code> define el color y <code>pixels.show()</code> actualiza el LED f\u00edsicamente.</p>"},{"location":"paginas/codigos_documentados/#ble-char","title":"///Ble-char","text":""},{"location":"paginas/codigos_documentados/#creacion-de-servicios-y-caracteristicas-ble","title":"Creaci\u00f3n de Servicios y Caracter\u00edsticas BLE","text":"<pre><code>#include &lt;BLEDevice.h&gt;   // Control del dispositivo BLE\n#include &lt;BLEServer.h&gt;   // Permite crear un servidor BLE\n#include &lt;BLEUtils.h&gt;    // Funciones auxiliares BLE\n#include &lt;BLE2902.h&gt;     // Permite agregar descriptores BLE\n\n#define SERVICE_UUIDA \"12345678-1234-1234-1234-1234567890ac\"\n#define CHARACTERISTIC_UUIDA \"abcd1234-ab12-cd34-ef56-abcdef123456\"\n#define SERVICE_UUIDB \"12345678-1234-1234-1234-1234567890ad\"\n#define CHARACTERISTIC_UUIDB \"abcd1234-ab12-cd34-ef56-abcdef123455\"\n#define CHARACTERISTIC_UUIDC \"abcd1234-ab12-cd34-ef56-abcdef123457\"\n\nvoid setup() {\n  Serial.begin(115200);              // Inicializa el monitor serial\n  BLEDevice::init(\"ESP32_BLee\");     // Crea un dispositivo BLE con nombre \"ESP32_BLee\"\n\n  BLEServer *pServer = BLEDevice::createServer(); // Crea el servidor BLE\n\n  // Primer servicio BLE\n  BLEService *pService = pServer-&gt;createService(SERVICE_UUIDA);\n  BLECharacteristic *pCharacteristic = pService-&gt;createCharacteristic(\n      CHARACTERISTIC_UUIDA,\n      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE);\n  pCharacteristic-&gt;setValue(\"Buenas nuevas nos trae el se\u00f1or\");\n  pService-&gt;start();\n\n  // Segundo servicio BLE con dos caracter\u00edsticas\n  BLEService *pServiceB = pServer-&gt;createService(SERVICE_UUIDB);\n  BLECharacteristic *pCharacteristicB = pServiceB-&gt;createCharacteristic(\n      CHARACTERISTIC_UUIDB,\n      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE);\n  pCharacteristicB-&gt;setValue(\"Silksong ma\u00f1ana\");\n\n  BLECharacteristic *pCharacteristicC = pServiceB-&gt;createCharacteristic(\n      CHARACTERISTIC_UUIDC,\n      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE);\n  pCharacteristicC-&gt;setValue(\"Prepara la cartera\");\n\n  pServiceB-&gt;start();\n\n  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();\n  pAdvertising-&gt;start();              // Comienza la difusi\u00f3n del dispositivo\n\n  Serial.println(\"Dispositivo BLE listo\");\n}\n\nvoid loop() {\n  delay(2000); // No hay l\u00f3gica activa en el bucle principal\n}\n</code></pre> <p>Explicaci\u00f3n detallada: Este c\u00f3digo crea dos servicios BLE con caracter\u00edsticas de lectura y escritura. Cada caracter\u00edstica tiene un UUID \u00fanico y un valor inicial que puede verse desde una app BLE. <code>BLEAdvertising</code> hace que el dispositivo sea detectable desde un tel\u00e9fono u otro cliente BLE.</p>"},{"location":"paginas/codigos_documentados/#ble-write","title":"///ble Write","text":""},{"location":"paginas/codigos_documentados/#control-del-led-integrado-por-bluetooth-ble","title":"Control del LED integrado por Bluetooth BLE","text":"<pre><code>#include &lt;BLEDevice.h&gt;\n#include &lt;BLEServer.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLE2902.h&gt;\n\n#define SERVICE_UUID \"12345678-1234-1234-1234-1234567890ab\"\n#define CHARACTERISTIC_UUID \"abcd1234-ab12-cd34-ef56-abcdef123456\"\n\n// Clase callback: maneja eventos cuando se escribe sobre la caracter\u00edstica BLE\nclass MyCallbacks : public BLECharacteristicCallbacks {\n  void onWrite(BLECharacteristic *pCharacteristic) {\n    String rxValue = pCharacteristic-&gt;getValue(); // Obtiene el valor recibido\n\n    if (rxValue.length() &gt; 0) {\n      Serial.print(\"Valor recibido: \");\n      Serial.println(rxValue.c_str());\n\n      if (rxValue == \"0\") {\n        digitalWrite(LED_BUILTIN, HIGH); // Enciende LED\n        Serial.println(\"LED ENCENDIDO\");\n      } else if (rxValue == \"1\") {\n        digitalWrite(LED_BUILTIN, LOW);  // Apaga LED\n        Serial.println(\"LED APAGADO\");\n      } else {\n        Serial.println(\"Usa '0' para prender y '1' para apagar.\");\n      }\n    }\n  }\n};\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  BLEDevice::init(\"ESP32_BLE_LED\");          // Inicia el dispositivo BLE\n  BLEServer *pServer = BLEDevice::createServer();\n  BLEService *pService = pServer-&gt;createService(SERVICE_UUID);\n\n  BLECharacteristic *pCharacteristic = pService-&gt;createCharacteristic(\n      CHARACTERISTIC_UUID,\n      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE);\n\n  pCharacteristic-&gt;setValue(\"1\");\n  pCharacteristic-&gt;setCallbacks(new MyCallbacks()); // Asigna la clase de manejo\n\n  pService-&gt;start();\n  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();\n  pAdvertising-&gt;start();\n\n  Serial.println(\"Esperando conexi\u00f3n BLE...\");\n}\n\nvoid loop() {\n  delay(1000);\n}\n</code></pre> <p>Explicaci\u00f3n: Cada vez que se recibe un valor BLE, se ejecuta el m\u00e9todo <code>onWrite()</code>. Seg\u00fan el valor (\u201c0\u201d o \u201c1\u201d), el LED se enciende o apaga.</p>"},{"location":"paginas/codigos_documentados/#wifi","title":"///Wifi","text":""},{"location":"paginas/codigos_documentados/#configuracion-del-modo-wifi-estacion","title":"Configuraci\u00f3n del modo WiFi estaci\u00f3n","text":"<pre><code>#include &lt;WiFi.h&gt;\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);     // Configura el ESP32 como estaci\u00f3n (no punto de acceso)\n  Serial.println(\"WiFi en modo estaci\u00f3n listo\");\n}\n\nvoid loop() {\n  delay(2000);\n}\n</code></pre> <p>Explicaci\u00f3n: <code>WiFi.mode(WIFI_STA)</code> permite que el ESP32 se comunique con otros dispositivos o redes. Es necesario para tecnolog\u00edas como ESP-NOW.</p>"},{"location":"paginas/codigos_documentados/#espnow","title":"///ESPnow","text":""},{"location":"paginas/codigos_documentados/#comunicacion-entre-esp32-receptor","title":"Comunicaci\u00f3n entre ESP32 (Receptor)","text":"<pre><code>#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\n\ntypedef struct struct_msj {\n  char a[32];\n  int b;\n  float c;\n  bool d;\n} struct_msj;\n\nstruct_msj datosRecibidos;\n\n// Funci\u00f3n callback: se ejecuta cuando llegan datos\nvoid OnDataRecv(const uint8_t * mac, const uint8_t *tempData, int tam) {\n  memcpy(&amp;datosRecibidos, tempData, sizeof(datosRecibidos)); // Copia los datos\n  Serial.print(\"Bytes recibidos: \"); Serial.println(tam);\n  Serial.print(\"Char: \"); Serial.println(datosRecibidos.a);\n  Serial.print(\"Int: \"); Serial.println(datosRecibidos.b);\n  Serial.print(\"Float: \"); Serial.println(datosRecibidos.c);\n  Serial.print(\"Bool: \"); Serial.println(datosRecibidos.d);\n  Serial.println();\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);  // Requerido para ESP-NOW\n\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error inicializando ESP-NOW\");\n    return;\n  }\n\n  esp_now_register_recv_cb(OnDataRecv); // Asigna la funci\u00f3n callback\n}\n\nvoid loop() {}\n</code></pre> <p>Explicaci\u00f3n: El ESP32 act\u00faa como receptor de mensajes. Cada vez que otro dispositivo env\u00eda datos, la funci\u00f3n <code>OnDataRecv</code> se activa autom\u00e1ticamente.</p>"},{"location":"paginas/codigos_documentados/#string-1","title":"///String 1","text":""},{"location":"paginas/codigos_documentados/#lectura-de-cadenas-desde-el-puerto-serial","title":"Lectura de cadenas desde el puerto serial","text":"<pre><code>String cmd = \"\";\n\nvoid setup() {\n  Serial.begin(115200); // Inicia el monitor serial\n}\n\nvoid loop() {\n  if (Serial.available() &gt; 0) {            // Si hay datos disponibles\n    cmd = Serial.readStringUntil('\\n');   // Lee hasta salto de l\u00ednea\n    Serial.println(cmd);                   // Imprime el texto recibido\n  }\n}\n</code></pre> <p>Explicaci\u00f3n l\u00ednea por l\u00ednea: - <code>Serial.available()</code> devuelve cu\u00e1ntos bytes est\u00e1n listos para leerse. - <code>readStringUntil('\\n')</code> lee hasta el final de la l\u00ednea. - <code>println()</code> imprime la cadena recibida.  </p>"},{"location":"paginas/espnow_receptor_documentado/","title":"Comunicaci\u00f3n ESP-NOW: Receptor","text":""},{"location":"paginas/espnow_receptor_documentado/#introduccion","title":"Introducci\u00f3n","text":"<p>El siguiente c\u00f3digo convierte el ESP32 en un receptor ESP-NOW, una tecnolog\u00eda de comunicaci\u00f3n directa sin necesidad de una red WiFi tradicional.</p>"},{"location":"paginas/espnow_receptor_documentado/#codigo-fuente","title":"C\u00f3digo fuente","text":"<pre><code>#include &lt;esp_now.h&gt;\n#include &lt;WiFi.h&gt;\n\ntypedef struct struct_msj {\n  char a[32];\n  int b;\n  float c;\n  bool d;\n} struct_msj;\n\nstruct_msj datosRecibidos;\n\nvoid OnDataRecv(const uint8_t * mac, const uint8_t *tempData, int tam) {\n  memcpy(&amp;datosRecibidos, tempData, sizeof(datosRecibidos));\n  Serial.print(\"Bytes recibidos: \"); Serial.println(tam);\n  Serial.print(\"Char: \"); Serial.println(datosRecibidos.a);\n  Serial.print(\"Int: \"); Serial.println(datosRecibidos.b);\n  Serial.print(\"Float: \"); Serial.println(datosRecibidos.c);\n  Serial.print(\"Bool: \"); Serial.println(datosRecibidos.d);\n  Serial.println();\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error inicializando ESP-NOW\");\n    return;\n  }\n  esp_now_register_recv_cb(OnDataRecv);\n}\n\nvoid loop() {}\n</code></pre>"},{"location":"paginas/espnow_receptor_documentado/#explicacion-detallada","title":"Explicaci\u00f3n detallada","text":"<ul> <li>WiFi.mode(WIFI_STA): El ESP32 debe estar en modo estaci\u00f3n.  </li> <li>esp_now_init(): Inicializa el protocolo ESP-NOW.  </li> <li>OnDataRecv: Se ejecuta autom\u00e1ticamente al recibir datos.  </li> <li>Estructura struct_msj: Permite recibir datos de distintos tipos (texto, n\u00famero, flotante y booleano).  </li> <li>Esta t\u00e9cnica se usa para redes r\u00e1pidas entre varios ESP32 sin router.</li> </ul>"},{"location":"paginas/neopixel_documentado/","title":"Control de NeoPixel con ESP32","text":""},{"location":"paginas/neopixel_documentado/#introduccion","title":"Introducci\u00f3n","text":"<p>Este programa demuestra c\u00f3mo inicializar y controlar un LED NeoPixel (WS2812 o similar) desde un ESP32. Se utiliza la librer\u00eda oficial de Adafruit para manejar LEDs RGB direccionables.</p>"},{"location":"paginas/neopixel_documentado/#codigo-fuente","title":"C\u00f3digo fuente","text":"<pre><code>#include &lt;Adafruit_NeoPixel.h&gt;\n#ifdef __AVR__\n#include &lt;avr/power.h&gt;\n#endif\n\n#define PIN 8\n#define NUMPIXELS 1\n\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nvoid setup(){\n  Serial.begin(115200);\n  pixels.begin();\n}\n\nvoid loop(){\n  pixels.clear();\n  pixels.setPixelColor(0, pixels.Color(122, 0, 122));\n  pixels.show();\n  delay(700);\n}\n</code></pre>"},{"location":"paginas/neopixel_documentado/#explicacion-detallada","title":"Explicaci\u00f3n detallada","text":"<ul> <li>Librer\u00edas: <code>Adafruit_NeoPixel</code> permite crear y controlar una o varias luces RGB direccionables.  </li> <li>Configuraci\u00f3n: Se define el pin de salida y el n\u00famero de LEDs (<code>NUMPIXELS</code>).  </li> <li>Inicio: <code>pixels.begin()</code> configura el pin y la se\u00f1al.  </li> <li>L\u00f3gica: En cada iteraci\u00f3n se limpia el estado anterior, se define un color magenta (122,0,122) y se muestra.  </li> <li>Retardo: <code>delay(700)</code> genera una pausa visible antes de volver a ejecutar el ciclo.</li> </ul>"},{"location":"paginas/string_serial_documentado/","title":"Lectura y eco de cadenas por Serial","text":""},{"location":"paginas/string_serial_documentado/#introduccion","title":"Introducci\u00f3n","text":"<p>Este c\u00f3digo realiza la lectura de texto ingresado por el monitor serial y lo devuelve como respuesta. Es una forma simple de probar comunicaci\u00f3n serial bidireccional.</p>"},{"location":"paginas/string_serial_documentado/#codigo-fuente","title":"C\u00f3digo fuente","text":"<pre><code>String cmd = \"\";\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  if (Serial.available() &gt; 0) {\n    cmd = Serial.readStringUntil('\\n');\n    Serial.println(cmd);\n  }\n}\n</code></pre>"},{"location":"paginas/string_serial_documentado/#explicacion-extendida","title":"Explicaci\u00f3n extendida","text":"<ul> <li>Serial.available(): Detecta si hay bytes listos para leerse.  </li> <li>readStringUntil('\\n'): Lee hasta un salto de l\u00ednea.  </li> <li>println(cmd): Devuelve el texto recibido, actuando como eco.  </li> <li>\u00datil para pruebas de comandos o comunicaci\u00f3n b\u00e1sica.</li> </ul>"},{"location":"paginas/wifi_documentado/","title":"Configuraci\u00f3n WiFi en modo estaci\u00f3n","text":""},{"location":"paginas/wifi_documentado/#introduccion","title":"Introducci\u00f3n","text":"<p>Este programa configura el ESP32 para operar como estaci\u00f3n WiFi (WIFI_STA), permitiendo conectarse a una red existente o habilitar otras funciones como ESP-NOW.</p>"},{"location":"paginas/wifi_documentado/#codigo-fuente","title":"C\u00f3digo fuente","text":"<pre><code>#include &lt;WiFi.h&gt;\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  Serial.println(\"WiFi en modo estaci\u00f3n listo\");\n}\n\nvoid loop() {\n  delay(2000);\n}\n</code></pre>"},{"location":"paginas/wifi_documentado/#explicacion","title":"Explicaci\u00f3n","text":"<ul> <li><code>WiFi.mode(WIFI_STA)</code> convierte el ESP32 en cliente WiFi.  </li> <li>Es necesario para protocolos como ESP-NOW o conexi\u00f3n a routers.  </li> <li>Ideal para m\u00f3dulos que act\u00faan como nodos dentro de una red.</li> </ul>"}]}